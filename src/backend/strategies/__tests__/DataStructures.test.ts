/**
 * Comprehensive Test Suite for Data Structures - Task BE-008 & BE-009
 * 
 * Tests all data frame implementations, performance benchmarking, memory optimization,
 * rolling windows, parameter sanitization, configuration validation, and default value handling.
 */

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { MarketDataFrame, IndicatorDataFrame, SignalDataFrame } from '../DataStructures.js';
import { 
  DataStructureBenchmark, 
  RollingWindow, 
  MultiTimeframeRollingWindows,
  DataValidator,
  createBenchmark,
  createRollingWindow,
  createMultiTimeframeWindows
} from '../../data/DataTransformations.js';
import { 
  ParameterSanitizer,
  createParameterSanitizer,
  createProductionSanitizer,
  sanitizeParameter
} from '../configuration/ParameterSanitizer.js';
import { 
  DefaultValueManager,
  createDefaultValueManager,
  getDefaultValue,
  mergeWithDefaults
} from '../configuration/DefaultValueManager.js';
import { StrategyConfigurationSystem } from '../configuration/StrategyConfigurationSystem.js';

// =============================================================================\n// DATA STRUCTURE TESTS\n// =============================================================================\n\ndescribe('MarketDataFrame', () => {\n  let dataFrame: MarketDataFrame;\n  \n  beforeEach(() => {\n    dataFrame = new MarketDataFrame();\n  });\n  \n  it('should create empty data frame', () => {\n    expect(dataFrame.size()).toBe(0);\n    expect(dataFrame.isEmpty()).toBe(true);\n  });\n  \n  it('should add candles correctly', () => {\n    const candle = {\n      timestamp: Date.now(),\n      open: 100,\n      high: 105,\n      low: 95,\n      close: 102,\n      volume: 1000\n    };\n    \n    dataFrame.addCandle(candle);\n    expect(dataFrame.size()).toBe(1);\n    expect(dataFrame.isEmpty()).toBe(false);\n  });\n  \n  it('should maintain chronological order', () => {\n    const candles = [\n      { timestamp: 1000, open: 100, high: 105, low: 95, close: 102, volume: 1000 },\n      { timestamp: 500, open: 98, high: 103, low: 93, close: 100, volume: 1200 },\n      { timestamp: 1500, open: 102, high: 107, low: 97, close: 105, volume: 800 }\n    ];\n    \n    candles.forEach(candle => dataFrame.addCandle(candle));\n    \n    const data = dataFrame.getData();\n    expect(data.length).toBe(3);\n    expect(data[0].timestamp).toBe(500);\n    expect(data[1].timestamp).toBe(1000);\n    expect(data[2].timestamp).toBe(1500);\n  });\n  \n  it('should extract price arrays correctly', () => {\n    const candles = [\n      { timestamp: 1000, open: 100, high: 105, low: 95, close: 102, volume: 1000 },\n      { timestamp: 2000, open: 102, high: 108, low: 98, close: 104, volume: 1200 }\n    ];\n    \n    candles.forEach(candle => dataFrame.addCandle(candle));\n    \n    const closes = dataFrame.getCloses();\n    expect(closes).toEqual([102, 104]);\n    \n    const highs = dataFrame.getHighs();\n    expect(highs).toEqual([105, 108]);\n  });\n  \n  it('should handle time-based queries', () => {\n    const candles = [\n      { timestamp: 1000, open: 100, high: 105, low: 95, close: 102, volume: 1000 },\n      { timestamp: 2000, open: 102, high: 108, low: 98, close: 104, volume: 1200 },\n      { timestamp: 3000, open: 104, high: 110, low: 100, close: 106, volume: 800 }\n    ];\n    \n    candles.forEach(candle => dataFrame.addCandle(candle));\n    \n    const range = dataFrame.getRange(1500, 2500);\n    expect(range.length).toBe(1);\n    expect(range[0].timestamp).toBe(2000);\n  });\n  \n  it('should merge data frames correctly', () => {\n    const df1 = new MarketDataFrame();\n    const df2 = new MarketDataFrame();\n    \n    df1.addCandle({ timestamp: 1000, open: 100, high: 105, low: 95, close: 102, volume: 1000 });\n    df2.addCandle({ timestamp: 2000, open: 102, high: 108, low: 98, close: 104, volume: 1200 });\n    \n    const merged = df1.merge(df2);\n    expect(merged.size()).toBe(2);\n  });\n  \n  it('should track performance metrics', () => {\n    // Add candles to trigger performance tracking\n    for (let i = 0; i < 100; i++) {\n      dataFrame.addCandle({\n        timestamp: i * 1000,\n        open: 100 + i,\n        high: 105 + i,\n        low: 95 + i,\n        close: 102 + i,\n        volume: 1000\n      });\n    }\n    \n    const metrics = (dataFrame as any).getPerformanceMetrics?.();\n    if (metrics) {\n      expect(metrics.operationCount).toBeGreaterThan(0);\n      expect(metrics.totalTime).toBeGreaterThanOrEqual(0);\n      expect(metrics.currentMemoryUsage).toBeGreaterThan(0);\n    }\n  });\n});\n\ndescribe('IndicatorDataFrame', () => {\n  let indicatorFrame: IndicatorDataFrame;\n  \n  beforeEach(() => {\n    indicatorFrame = new IndicatorDataFrame();\n  });\n  \n  it('should add indicators correctly', () => {\n    const values = [10, 15, 12, 18, 20];\n    const timestamps = [1000, 2000, 3000, 4000, 5000];\n    \n    indicatorFrame.addIndicator('SMA_20', values, timestamps);\n    \n    const indicator = indicatorFrame.getIndicator('SMA_20');\n    expect(indicator).toBeDefined();\n    expect(indicator!.values).toEqual(values);\n    expect(indicator!.timestamps).toEqual(timestamps);\n  });\n  \n  it('should handle multiple indicators', () => {\n    indicatorFrame.addIndicator('SMA_20', [10, 15, 20]);\n    indicatorFrame.addIndicator('EMA_12', [12, 16, 18]);\n    \n    const indicators = indicatorFrame.getAllIndicators();\n    expect(Object.keys(indicators)).toHaveLength(2);\n    expect(indicators['SMA_20']).toBeDefined();\n    expect(indicators['EMA_12']).toBeDefined();\n  });\n  \n  it('should align indicators by timestamp', () => {\n    indicatorFrame.addIndicator('SMA_20', [10, 15], [1000, 2000]);\n    indicatorFrame.addIndicator('EMA_12', [12, 16], [1000, 2000]);\n    \n    const aligned = indicatorFrame.getAlignedData([1000, 2000]);\n    expect(aligned.length).toBe(2);\n    expect(aligned[0]).toHaveProperty('SMA_20', 10);\n    expect(aligned[0]).toHaveProperty('EMA_12', 12);\n  });\n  \n  it('should slice indicators correctly', () => {\n    indicatorFrame.addIndicator('TEST', [1, 2, 3, 4, 5]);\n    \n    const sliced = indicatorFrame.slice(1, 4);\n    const testIndicator = sliced.getIndicator('TEST');\n    \n    expect(testIndicator!.values).toEqual([2, 3, 4]);\n  });\n  \n  it('should calculate correlations', () => {\n    indicatorFrame.addIndicator('IND1', [1, 2, 3, 4, 5]);\n    indicatorFrame.addIndicator('IND2', [2, 4, 6, 8, 10]);\n    \n    const correlation = (indicatorFrame as any).calculateCorrelation?.('IND1', 'IND2');\n    if (correlation !== undefined) {\n      expect(correlation).toBeCloseTo(1.0, 2); // Perfect positive correlation\n    }\n  });\n});\n\ndescribe('SignalDataFrame', () => {\n  let signalFrame: SignalDataFrame;\n  \n  beforeEach(() => {\n    signalFrame = new SignalDataFrame();\n  });\n  \n  it('should add signals correctly', () => {\n    const signal = {\n      id: 'signal_1',\n      type: 'entry' as const,\n      timestamp: new Date(),\n      symbol: 'BTC-USD',\n      confidence: 0.8,\n      isValid: true,\n      strategyId: 'test_strategy',\n      indicators: {}\n    };\n    \n    signalFrame.addSignal(signal);\n    expect(signalFrame.size()).toBe(1);\n  });\n  \n  it('should filter signals by type', () => {\n    const signals = [\n      { id: '1', type: 'entry' as const, timestamp: new Date(), symbol: 'BTC-USD', confidence: 0.8, isValid: true, strategyId: 'test', indicators: {} },\n      { id: '2', type: 'exit' as const, timestamp: new Date(), symbol: 'BTC-USD', confidence: 0.7, isValid: true, strategyId: 'test', indicators: {} },\n      { id: '3', type: 'entry' as const, timestamp: new Date(), symbol: 'BTC-USD', confidence: 0.9, isValid: true, strategyId: 'test', indicators: {} }\n    ];\n    \n    signals.forEach(signal => signalFrame.addSignal(signal));\n    \n    const entrySignals = signalFrame.filterByType('entry');\n    expect(entrySignals.length).toBe(2);\n  });\n  \n  it('should get signals by time range', () => {\n    const now = new Date();\n    const past = new Date(now.getTime() - 60000); // 1 minute ago\n    const future = new Date(now.getTime() + 60000); // 1 minute from now\n    \n    signalFrame.addSignal({\n      id: '1', type: 'entry', timestamp: past, symbol: 'BTC-USD',\n      confidence: 0.8, isValid: true, strategyId: 'test', indicators: {}\n    });\n    signalFrame.addSignal({\n      id: '2', type: 'exit', timestamp: future, symbol: 'BTC-USD',\n      confidence: 0.7, isValid: true, strategyId: 'test', indicators: {}\n    });\n    \n    const signals = signalFrame.getSignalsByTimeRange(past, future);\n    expect(signals.length).toBe(2);\n  });\n  \n  it('should analyze signal performance', () => {\n    const signals = [\n      { id: '1', type: 'entry' as const, timestamp: new Date(), symbol: 'BTC-USD', confidence: 0.8, isValid: true, strategyId: 'test', indicators: {} },\n      { id: '2', type: 'exit' as const, timestamp: new Date(), symbol: 'BTC-USD', confidence: 0.7, isValid: false, strategyId: 'test', indicators: {} },\n      { id: '3', type: 'entry' as const, timestamp: new Date(), symbol: 'BTC-USD', confidence: 0.9, isValid: true, strategyId: 'test', indicators: {} }\n    ];\n    \n    signals.forEach(signal => signalFrame.addSignal(signal));\n    \n    const analysis = (signalFrame as any).analyzeSignalPerformance?.();\n    if (analysis) {\n      expect(analysis.totalSignals).toBe(3);\n      expect(analysis.validityRate).toBeCloseTo(0.67, 2);\n    }\n  });\n});\n\n// =============================================================================\n// PERFORMANCE BENCHMARKING TESTS\n// =============================================================================\n\ndescribe('DataStructureBenchmark', () => {\n  let benchmark: DataStructureBenchmark;\n  \n  beforeEach(() => {\n    benchmark = createBenchmark();\n  });\n  \n  it('should benchmark simple operations', async () => {\n    const result = await benchmark.benchmark(\n      'simple_addition',\n      () => 1 + 1,\n      100\n    );\n    \n    expect(result.operation).toBe('simple_addition');\n    expect(result.iterations).toBe(100);\n    expect(result.totalTime).toBeGreaterThan(0);\n    expect(result.averageTime).toBeGreaterThan(0);\n    expect(result.throughput).toBeGreaterThan(0);\n    expect(result.memoryUsage).toBeDefined();\n  });\n  \n  it('should provide performance summary', async () => {\n    await benchmark.benchmark('op1', () => Math.random(), 50);\n    await benchmark.benchmark('op2', () => Math.sqrt(100), 50);\n    \n    const summary = benchmark.getSummary();\n    \n    expect(summary.totalBenchmarks).toBe(2);\n    expect(summary.averageThroughput).toBeGreaterThan(0);\n    expect(summary.fastestOperation).toBeDefined();\n    expect(summary.slowestOperation).toBeDefined();\n  });\n  \n  it('should benchmark data frame operations', async () => {\n    const results = await benchmark.benchmarkDataFrameOperations();\n    \n    expect(results.marketDataFrame).toBeDefined();\n    expect(results.indicatorDataFrame).toBeDefined();\n    expect(results.signalDataFrame).toBeDefined();\n    \n    // Check that we have results for each category\n    expect(results.marketDataFrame.length).toBeGreaterThan(0);\n    expect(results.indicatorDataFrame.length).toBeGreaterThan(0);\n    expect(results.signalDataFrame.length).toBeGreaterThan(0);\n  });\n});\n\n// =============================================================================\n// ROLLING WINDOW TESTS\n// =============================================================================\n\ndescribe('RollingWindow', () => {\n  let window: RollingWindow<number>;\n  \n  beforeEach(() => {\n    window = createRollingWindow<number>(5);\n  });\n  \n  it('should maintain capacity limit', () => {\n    for (let i = 0; i < 10; i++) {\n      window.add(i);\n    }\n    \n    expect(window.getSize()).toBe(5);\n    expect(window.isFull()).toBe(true);\n  });\n  \n  it('should calculate rolling statistics', () => {\n    [1, 2, 3, 4, 5].forEach(val => window.add(val));\n    \n    expect(window.getMean()).toBe(3);\n    expect(window.getStandardDeviation()).toBeCloseTo(1.58, 2);\n  });\n  \n  it('should return values in chronological order', () => {\n    [1, 2, 3].forEach(val => window.add(val));\n    \n    const values = window.getValues();\n    expect(values).toEqual([1, 2, 3]);\n  });\n  \n  it('should handle overflow correctly', () => {\n    for (let i = 1; i <= 7; i++) {\n      window.add(i);\n    }\n    \n    // Should contain last 5 values: [3, 4, 5, 6, 7]\n    const values = window.getValues();\n    expect(values).toEqual([3, 4, 5, 6, 7]);\n    expect(window.getOldest()).toBe(3);\n    expect(window.getLatest()).toBe(7);\n  });\n});\n\ndescribe('MultiTimeframeRollingWindows', () => {\n  let windows: MultiTimeframeRollingWindows;\n  \n  beforeEach(() => {\n    windows = createMultiTimeframeWindows([\n      { name: '5m', size: 5 },\n      { name: '15m', size: 3 },\n      { name: '1h', size: 2 }\n    ]);\n  });\n  \n  it('should update all timeframes simultaneously', () => {\n    windows.addValue(100);\n    windows.addValue(105);\n    \n    const stats = windows.getStatistics();\n    \n    expect(stats['5m'].size).toBe(2);\n    expect(stats['15m'].size).toBe(2);\n    expect(stats['1h'].size).toBe(2);\n    \n    expect(stats['5m'].mean).toBe(102.5);\n    expect(stats['15m'].mean).toBe(102.5);\n    expect(stats['1h'].mean).toBe(102.5);\n  });\n  \n  it('should provide individual window access', () => {\n    const window5m = windows.getWindow('5m');\n    expect(window5m).toBeDefined();\n    \n    window5m!.add(50);\n    const stats = windows.getStatistics();\n    expect(stats['5m'].latest).toBe(50);\n  });\n});\n\n// =============================================================================\n// DATA VALIDATION TESTS\n// =============================================================================\n\ndescribe('DataValidator', () => {\n  it('should validate OHLCV data correctly', () => {\n    const validCandle = {\n      timestamp: Date.now(),\n      open: 100,\n      high: 105,\n      low: 95,\n      close: 102,\n      volume: 1000\n    };\n    \n    const result = DataValidator.validateOHLCV(validCandle);\n    expect(result.isValid).toBe(true);\n    expect(result.errors.length).toBe(0);\n  });\n  \n  it('should detect invalid OHLCV relationships', () => {\n    const invalidCandle = {\n      timestamp: Date.now(),\n      open: 100,\n      high: 95, // High should be >= open/close\n      low: 105, // Low should be <= open/close\n      close: 102,\n      volume: 1000\n    };\n    \n    const result = DataValidator.validateOHLCV(invalidCandle);\n    expect(result.isValid).toBe(false);\n    expect(result.errors.length).toBeGreaterThan(0);\n  });\n  \n  it('should validate indicator arrays', () => {\n    const validIndicator = [10, 15, 12, 18, 20];\n    const result = DataValidator.validateIndicator('SMA_20', validIndicator);\n    \n    expect(result.isValid).toBe(true);\n    expect(result.errors.length).toBe(0);\n  });\n  \n  it('should detect problematic indicator values', () => {\n    const problematicIndicator = [10, NaN, 12, Infinity, 20];\n    const result = DataValidator.validateIndicator('RSI', problematicIndicator);\n    \n    expect(result.isValid).toBe(false);\n    expect(result.errors.some(e => e.includes('infinite'))).toBe(true);\n    expect(result.warnings.some(w => w.includes('NaN'))).toBe(true);\n  });\n  \n  it('should batch validate multiple indicators', () => {\n    const indicators = {\n      'SMA_20': [10, 15, 20],\n      'RSI': [30, 50, 70],\n      'INVALID': [NaN, Infinity]\n    };\n    \n    const result = DataValidator.batchValidateIndicators(indicators);\n    \n    expect(result.summary.totalIndicators).toBe(3);\n    expect(result.summary.validIndicators).toBe(2);\n    expect(result.summary.totalErrors).toBeGreaterThan(0);\n    expect(result.results['INVALID'].isValid).toBe(false);\n  });\n});\n\n// =============================================================================\n// PARAMETER SANITIZATION TESTS\n// =============================================================================\n\ndescribe('ParameterSanitizer', () => {\n  let sanitizer: ParameterSanitizer;\n  \n  beforeEach(() => {\n    sanitizer = createParameterSanitizer();\n  });\n  \n  it('should sanitize string parameters', async () => {\n    const result = await sanitizer.sanitize(' BTC/USD ', {\n      parameterPath: 'symbol',\n      parameterType: 'symbol',\n      depth: 0\n    });\n    \n    expect(result.isValid).toBe(true);\n    expect(result.sanitized).toBe('BTC-USD'); // Normalized\n    expect(result.changes.length).toBeGreaterThan(0);\n  });\n  \n  it('should detect security threats', async () => {\n    const maliciousInput = '<script>alert(\"xss\")</script>';\n    \n    const result = await sanitizer.sanitize(maliciousInput, {\n      parameterPath: 'userInput',\n      parameterType: 'string',\n      depth: 0\n    });\n    \n    expect(result.securityFlags.length).toBeGreaterThan(0);\n    expect(result.sanitized).not.toContain('<script>');\n  });\n  \n  it('should validate number parameters', async () => {\n    const result = await sanitizer.sanitize(123.456789012345, {\n      parameterPath: 'price',\n      parameterType: 'price',\n      depth: 0\n    });\n    \n    expect(result.isValid).toBe(true);\n    expect(typeof result.sanitized).toBe('number');\n  });\n  \n  it('should sanitize nested objects', async () => {\n    const complexObject = {\n      symbol: ' eth/btc ',\n      amount: 123.456789,\n      settings: {\n        enabled: 'true',\n        timeout: '30'\n      }\n    };\n    \n    const result = await sanitizer.sanitize(complexObject, {\n      parameterPath: 'config',\n      parameterType: 'object',\n      depth: 0\n    });\n    \n    expect(result.isValid).toBe(true);\n    expect(result.sanitized).toBeDefined();\n  });\n  \n  it('should handle production vs development modes', async () => {\n    const prodSanitizer = createProductionSanitizer();\n    \n    const longString = 'a'.repeat(2000);\n    const result = await prodSanitizer.sanitize(longString, {\n      parameterPath: 'input',\n      parameterType: 'string',\n      depth: 0\n    });\n    \n    expect(result.sanitized).toHaveProperty('length');\n    expect((result.sanitized as string).length).toBeLessThanOrEqual(1000);\n  });\n  \n  it('should use quick sanitization function', async () => {\n    const result = await sanitizeParameter('BTC/USD', 'symbol', 'symbol');\n    expect(result).toBe('BTC-USD');\n  });\n});\n\n// =============================================================================\n// DEFAULT VALUE MANAGER TESTS\n// =============================================================================\n\ndescribe('DefaultValueManager', () => {\n  let manager: DefaultValueManager;\n  \n  beforeEach(() => {\n    manager = createDefaultValueManager();\n  });\n  \n  it('should provide system defaults', async () => {\n    const result = await manager.getDefaultValue('maxRiskPerTrade', {\n      parameterType: 'percentage',\n      strategyType: 'base',\n      environment: 'development'\n    });\n    \n    expect(result.value).toBe(2);\n    expect(result.source).toBe('system');\n  });\n  \n  it('should apply environment-specific defaults', async () => {\n    const result = await manager.getDefaultValue('paperTrading', {\n      parameterType: 'boolean',\n      strategyType: 'base',\n      environment: 'development'\n    });\n    \n    expect(result.value).toBe(true);\n    expect(result.appliedRules.length).toBeGreaterThan(0);\n  });\n  \n  it('should handle strategy-specific defaults', async () => {\n    const result = await manager.getDefaultValue('timeframes', {\n      parameterType: 'array',\n      strategyType: 'scalping',\n      environment: 'development'\n    });\n    \n    expect(result.value).toEqual(['1m', '5m']);\n    expect(result.source).toBe('strategy');\n  });\n  \n  it('should handle inheritance chains', async () => {\n    const result = await manager.getDefaultValue('maxRiskPerTrade', {\n      parameterType: 'percentage',\n      strategyType: 'ma_crossover',\n      environment: 'development',\n      parentStrategy: 'trend_following'\n    });\n    \n    expect(result.value).toBeDefined();\n    expect(['inherited', 'strategy', 'system']).toContain(result.source);\n  });\n  \n  it('should merge user config with defaults', async () => {\n    const userConfig = {\n      symbol: 'BTC-USD',\n      customParam: 'test'\n    };\n    \n    const merged = await mergeWithDefaults(userConfig, 'base', 'development');\n    \n    expect(merged.symbol).toBe('BTC-USD'); // User value preserved\n    expect(merged.customParam).toBe('test'); // User value preserved\n    expect(merged.maxRiskPerTrade).toBeDefined(); // Default added\n  });\n  \n  it('should use quick default value function', async () => {\n    const value = await getDefaultValue('smaLength', 'number', 'trend_following', 'development');\n    expect(value).toBe(20);\n  });\n});\n\n// =============================================================================\n// STRATEGY CONFIGURATION SYSTEM TESTS\n// =============================================================================\n\ndescribe('StrategyConfigurationSystem', () => {\n  let configSystem: StrategyConfigurationSystem;\n  \n  beforeEach(() => {\n    configSystem = new StrategyConfigurationSystem();\n  });\n  \n  it('should validate basic configuration structure', async () => {\n    const config = {\n      id: 'test_strategy',\n      name: 'Test Strategy',\n      type: 'trend_following',\n      timeframes: ['1h'],\n      symbols: ['BTC-USD'],\n      parameters: {},\n      riskProfile: {\n        maxRiskPerTrade: 2,\n        maxPortfolioRisk: 10,\n        stopLossEnabled: true\n      },\n      performance: {\n        targetReturn: 15,\n        maxDrawdown: 10,\n        minWinRate: 60\n      },\n      execution: {\n        timeout: 30,\n        retries: 3,\n        slippage: 0.1\n      },\n      monitoring: {\n        enabled: true,\n        alertThresholds: {\n          loss: 5,\n          drawdown: 8\n        }\n      }\n    };\n    \n    const result = await configSystem.validateConfiguration(config as any);\n    \n    expect(result.isValid).toBe(true);\n    expect(result.errors.length).toBe(0);\n    expect(result.healthScore).toBeGreaterThan(50);\n  });\n  \n  it('should detect configuration errors', async () => {\n    const invalidConfig = {\n      id: 'invalid_strategy',\n      name: 'Invalid Strategy',\n      type: 'unknown_type',\n      timeframes: [], // Empty array should trigger error\n      symbols: [],    // Empty array should trigger error\n      parameters: {},\n      riskProfile: {\n        maxRiskPerTrade: -5, // Negative risk should trigger error\n        maxPortfolioRisk: 150, // > 100 should trigger error\n        stopLossEnabled: true\n      }\n    };\n    \n    const result = await configSystem.validateConfiguration(invalidConfig as any);\n    \n    expect(result.isValid).toBe(false);\n    expect(result.errors.length).toBeGreaterThan(0);\n    expect(result.healthScore).toBeLessThan(50);\n  });\n  \n  it('should provide validation recommendations', async () => {\n    const config = {\n      id: 'test_strategy',\n      name: 'Test Strategy', \n      type: 'trend_following',\n      timeframes: ['1h'],\n      symbols: ['BTC-USD'],\n      parameters: {},\n      riskProfile: {\n        maxRiskPerTrade: 8, // High risk should trigger warning\n        maxPortfolioRisk: 25,\n        stopLossEnabled: false\n      }\n    };\n    \n    const result = await configSystem.validateConfiguration(config as any);\n    \n    expect(result.recommendations.length).toBeGreaterThan(0);\n    expect(result.warnings.length).toBeGreaterThan(0);\n  });\n  \n  it('should track validation metrics', () => {\n    const metrics = configSystem.getValidationMetrics();\n    \n    expect(metrics).toHaveProperty('totalValidations');\n    expect(metrics).toHaveProperty('avgValidationTime');\n    expect(metrics).toHaveProperty('successRate');\n  });\n});\n\n// =============================================================================\n// INTEGRATION TESTS\n// =============================================================================\n\ndescribe('Integration Tests', () => {\n  it('should integrate data structures with performance tracking', async () => {\n    const dataFrame = new MarketDataFrame();\n    const benchmark = createBenchmark();\n    \n    // Add data and benchmark performance\n    const result = await benchmark.benchmark(\n      'dataframe_operations',\n      () => {\n        dataFrame.addCandle({\n          timestamp: Date.now(),\n          open: Math.random() * 100,\n          high: Math.random() * 100 + 100,\n          low: Math.random() * 100,\n          close: Math.random() * 100 + 50,\n          volume: Math.random() * 1000\n        });\n      },\n      100\n    );\n    \n    expect(result.throughput).toBeGreaterThan(100); // Should be fast\n    expect(dataFrame.size()).toBe(100);\n  });\n  \n  it('should integrate sanitization with configuration validation', async () => {\n    const sanitizer = createParameterSanitizer();\n    const configSystem = new StrategyConfigurationSystem();\n    \n    // Sanitize input first\n    const rawSymbol = ' btc/usd ';\n    const sanitizedSymbol = await sanitizeParameter(rawSymbol, 'symbol', 'symbol');\n    \n    // Use sanitized value in configuration\n    const config = {\n      id: 'integration_test',\n      name: 'Integration Test',\n      type: 'base',\n      timeframes: ['1h'],\n      symbols: [sanitizedSymbol],\n      parameters: {}\n    };\n    \n    const result = await configSystem.validateConfiguration(config as any);\n    \n    expect(sanitizedSymbol).toBe('BTC-USD');\n    expect(result.isValid).toBe(true);\n  });\n  \n  it('should integrate default values with configuration', async () => {\n    const manager = createDefaultValueManager();\n    const configSystem = new StrategyConfigurationSystem();\n    \n    // Get defaults for a strategy\n    const merged = await mergeWithDefaults(\n      { symbol: 'BTC-USD' },\n      'trend_following',\n      'development'\n    );\n    \n    // Validate the merged configuration\n    const config = {\n      id: 'defaults_test',\n      name: 'Defaults Test',\n      type: 'trend_following',\n      timeframes: merged.timeframes || ['1h'],\n      symbols: [merged.symbol as string],\n      parameters: {},\n      riskProfile: {\n        maxRiskPerTrade: merged.maxRiskPerTrade as number,\n        maxPortfolioRisk: merged.maxPortfolioRisk as number,\n        stopLossEnabled: true\n      }\n    };\n    \n    const result = await configSystem.validateConfiguration(config as any);\n    \n    expect(result.isValid).toBe(true);\n    expect(config.riskProfile.maxRiskPerTrade).toBeDefined();\n    expect(config.timeframes).toBeDefined();\n  });\n});"